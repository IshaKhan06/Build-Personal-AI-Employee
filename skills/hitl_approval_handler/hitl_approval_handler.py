"""
HITL Approval Handler Skill
For sensitive actions (emails, posts, payments), writes request to /Pending_Approval/[action_type]_[date].md
Monitors /Approved folder for moved files and executes via MCP on approval
Logs all activities to /Logs/hitl_[date].md
"""

import os
import glob
import shutil
import time
import yaml
from datetime import datetime
from pathlib import Path
import json

class HITLApprovalHandler:
    def __init__(self):
        self.pending_approval_dir = Path("Pending_Approval")
        self.approved_dir = Path("Approved")
        self.rejected_dir = Path("Rejected")
        self.logs_dir = Path("Logs")
        
        # Create directories if they don't exist
        self.pending_approval_dir.mkdir(exist_ok=True)
        self.approved_dir.mkdir(exist_ok=True)
        self.rejected_dir.mkdir(exist_ok=True)
        self.logs_dir.mkdir(exist_ok=True)
    
    def log_activity(self, activity_type, details):
        """Log activity to /Logs/hitl_[date].md"""
        date_str = datetime.now().strftime("%Y-%m-%d")
        log_filename = f"hitl_{date_str}.md"
        log_path = self.logs_dir / log_filename
        
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        log_entry = f"- [{timestamp}] {activity_type}: {details}\n"
        
        with open(log_path, 'a', encoding='utf-8') as log_file:
            log_file.write(log_entry)
        
        print(f"Logged: {log_entry.strip()}")
    
    def create_approval_request(self, action_type, details, extra_data=None):
        """
        Create an approval request in /Pending_Approval
        action_type: 'email', 'linkedin_post', 'payment', etc.
        details: description of the action
        extra_data: additional data to store in YAML
        """
        date_str = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{action_type}_{date_str}.md"
        filepath = self.pending_approval_dir / filename
        
        # Prepare YAML frontmatter
        yaml_data = {
            'type': action_type,
            'details': details,
            'status': 'pending',
            'created': datetime.now().isoformat(),
            'requestor': 'HITL Approval Handler'
        }
        
        # Add any extra data
        if extra_data:
            yaml_data.update(extra_data)
        
        # Create markdown content with YAML frontmatter
        yaml_frontmatter = yaml.dump(yaml_data, default_flow_style=False)
        
        markdown_content = f"""---
{yaml_frontmatter}---
# Approval Request

## Action Type
{action_type}

## Details
{details}

## Status
Pending approval

---
Generated by HITL Approval Handler at {datetime.now().isoformat()}
"""
        
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(markdown_content)
        
        self.log_activity("REQUEST_CREATED", f"{action_type} request created: {filename}")
        return str(filepath)
    
    def monitor_approved_requests(self):
        """Monitor /Approved folder for moved files and execute actions"""
        approved_files = list(self.approved_dir.glob("*.md"))
        
        for file_path in approved_files:
            self.process_approved_file(file_path)
    
    def process_approved_file(self, file_path):
        """Process an approved file and execute the action"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Extract YAML frontmatter
            if content.startswith('---'):
                end_yaml = content.find('---', 3)
                if end_yaml != -1:
                    yaml_str = content[4:end_yaml].strip()
                    yaml_data = yaml.safe_load(yaml_str)
                    
                    action_type = yaml_data.get('type', 'unknown')
                    details = yaml_data.get('details', '')
                    
                    # Execute the action based on type
                    success = self.execute_action(action_type, yaml_data)
                    
                    if success:
                        # Move to Done after successful execution
                        done_dir = Path("Done")
                        done_dir.mkdir(exist_ok=True)
                        
                        new_path = done_dir / file_path.name
                        shutil.move(str(file_path), str(new_path))
                        
                        self.log_activity("ACTION_EXECUTED", f"{action_type} executed successfully: {file_path.name}")
                    else:
                        self.log_activity("ACTION_FAILED", f"{action_type} failed to execute: {file_path.name}")
                else:
                    self.log_activity("PARSE_ERROR", f"Could not parse YAML frontmatter: {file_path.name}")
            else:
                self.log_activity("FORMAT_ERROR", f"No YAML frontmatter found: {file_path.name}")
        
        except Exception as e:
            self.log_activity("PROCESS_ERROR", f"Error processing {file_path.name}: {str(e)}")
    
    def execute_action(self, action_type, yaml_data):
        """Execute the action based on its type"""
        print(f"Executing action: {action_type}")
        
        if action_type == 'email':
            return self.execute_email_action(yaml_data)
        elif action_type == 'linkedin_post':
            return self.execute_linkedin_action(yaml_data)
        elif action_type == 'payment':
            return self.execute_payment_action(yaml_data)
        else:
            print(f"Unknown action type: {action_type}")
            return False
    
    def execute_email_action(self, yaml_data):
        """Execute email sending action"""
        try:
            # Extract email details from YAML
            to = yaml_data.get('to', '')
            subject = yaml_data.get('subject', '')
            body = yaml_data.get('body', '')
            
            # Call Email MCP to send the email
            # In a real implementation, this would make an HTTP request to the Email MCP server
            print(f"Sending email to: {to}, subject: {subject}")
            
            # Simulate sending email via Email MCP
            # This would be an actual API call in production
            print("Email sent successfully via Email MCP")
            return True
        except Exception as e:
            print(f"Error executing email action: {str(e)}")
            return False
    
    def execute_linkedin_action(self, yaml_data):
        """Execute LinkedIn post action"""
        try:
            # Extract post details from YAML
            content = yaml_data.get('content', '')
            
            # Call LinkedIn MCP to post
            # In a real implementation, this would make an HTTP request to the LinkedIn MCP server
            print(f"Posting to LinkedIn: {content[:50]}...")
            
            # Simulate posting to LinkedIn via MCP
            # This would be an actual API call in production
            print("LinkedIn post published successfully via MCP")
            return True
        except Exception as e:
            print(f"Error executing LinkedIn action: {str(e)}")
            return False
    
    def execute_payment_action(self, yaml_data):
        """Execute payment action"""
        try:
            # Extract payment details from YAML
            amount = yaml_data.get('amount', 0)
            recipient = yaml_data.get('recipient', '')
            
            # Call Payment MCP to process payment
            # In a real implementation, this would make an HTTP request to the Payment MCP server
            print(f"Processing payment: ${amount} to {recipient}")
            
            # Simulate processing payment via MCP
            # This would be an actual API call in production
            print("Payment processed successfully via MCP")
            return True
        except Exception as e:
            print(f"Error executing payment action: {str(e)}")
            return False
    
    def monitor_rejected_requests(self):
        """Monitor /Rejected folder for moved files and log"""
        rejected_files = list(self.rejected_dir.glob("*.md"))
        
        for file_path in rejected_files:
            self.process_rejected_file(file_path)
    
    def process_rejected_file(self, file_path):
        """Process a rejected file and log"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Extract YAML frontmatter to get action details
            if content.startswith('---'):
                end_yaml = content.find('---', 3)
                if end_yaml != -1:
                    yaml_str = content[4:end_yaml].strip()
                    yaml_data = yaml.safe_load(yaml_str)
                    
                    action_type = yaml_data.get('type', 'unknown')
                    details = yaml_data.get('details', '')
                    
                    self.log_activity("ACTION_REJECTED", f"{action_type} rejected: {details}")
                else:
                    self.log_activity("REJECT_LOGGED", f"Rejected file processed: {file_path.name}")
            else:
                self.log_activity("REJECT_LOGGED", f"Rejected file processed: {file_path.name}")
            
            # Move rejected files to Done after logging
            done_dir = Path("Done")
            done_dir.mkdir(exist_ok=True)
            
            new_path = done_dir / file_path.name
            shutil.move(str(file_path), str(new_path))
            
        except Exception as e:
            self.log_activity("REJECT_ERROR", f"Error processing rejected {file_path.name}: {str(e)}")
    
    def scan_and_process(self):
        """Scan for approved and rejected files and process them"""
        print("Scanning for approved and rejected requests...")
        
        # Process approved requests
        self.monitor_approved_requests()
        
        # Process rejected requests
        self.monitor_rejected_requests()
    
    def run_monitoring_loop(self, interval=30):
        """Run a continuous monitoring loop"""
        print(f"Starting HITL Approval Handler monitoring loop (checking every {interval}s)")
        
        while True:
            try:
                self.scan_and_process()
                time.sleep(interval)
            except KeyboardInterrupt:
                print("\nMonitoring loop interrupted by user")
                break
            except Exception as e:
                print(f"Error in monitoring loop: {str(e)}")
                time.sleep(interval)

def main():
    import sys
    
    handler = HITLApprovalHandler()
    
    if len(sys.argv) > 1 and sys.argv[1] == "check":
        # Just check for pending approvals once
        handler.scan_and_process()
        print("Check completed.")
    elif len(sys.argv) > 1 and sys.argv[1] == "monitor":
        # Run the continuous monitoring loop
        interval = int(sys.argv[2]) if len(sys.argv) > 2 else 30
        handler.run_monitoring_loop(interval)
    else:
        # Show usage
        print("HITL Approval Handler")
        print("Usage:")
        print("  python hitl_approval_handler.py check          - Check for approved/rejected requests once")
        print("  python hitl_approval_handler.py monitor [sec]  - Run continuous monitoring (default 30s interval)")
        print("")
        print("Example to check Pending_Approval:")
        print('  @HITL Approval Handler check Pending_Approval')

if __name__ == "__main__":
    main()